<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Unsafe.Coerce</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">base-4.19.1.0: Basic libraries</span><ul class="links" id="page-menu"><li><a href="src/Unsafe.Coerce.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Unsafe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Unsafe.Coerce</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:unsafeCoerce">unsafeCoerce</a> :: a -&gt; b</li><li class="src short"><a href="#v:unsafeCoerceUnlifted">unsafeCoerceUnlifted</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Exts.html#t:UnliftedType" title="GHC.Exts">UnliftedType</a>) (b :: <a href="GHC-Exts.html#t:UnliftedType" title="GHC.Exts">UnliftedType</a>). a -&gt; b</li><li class="src short"><a href="#v:unsafeCoerceAddr">unsafeCoerceAddr</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> '<a href="GHC-Exts.html#v:AddrRep" title="GHC.Exts">AddrRep</a>) (b :: <a href="GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> '<a href="GHC-Exts.html#v:AddrRep" title="GHC.Exts">AddrRep</a>). a -&gt; b</li><li class="src short"><a href="#v:unsafeEqualityProof">unsafeEqualityProof</a> :: <span class="keyword">forall</span> {k} (a :: k) (b :: k). <a href="Unsafe-Coerce.html#t:UnsafeEquality" title="Unsafe.Coerce">UnsafeEquality</a> a b</li><li class="src short"><span class="keyword">data</span> <a href="#t:UnsafeEquality">UnsafeEquality</a> (a :: k) (b :: k) <span class="keyword">where</span><ul class="subs"><li><a href="#v:UnsafeRefl">UnsafeRefl</a> :: <span class="keyword">forall</span> {k} (a :: k). <a href="Unsafe-Coerce.html#t:UnsafeEquality" title="Unsafe.Coerce">UnsafeEquality</a> a a</li></ul></li><li class="src short"><a href="#v:unsafeCoerce-35-">unsafeCoerce#</a> :: a -&gt; b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:unsafeCoerce" class="def">unsafeCoerce</a> :: a -&gt; b <a href="src/Unsafe.Coerce.html#unsafeCoerce" class="link">Source</a> <a href="#v:unsafeCoerce" class="selflink">#</a></p><div class="doc"><p><code><a href="Unsafe-Coerce.html#v:unsafeCoerce" title="Unsafe.Coerce">unsafeCoerce</a></code> coerces a value from one type to another, bypassing the type-checker.</p><p>There are several legitimate ways to use <code><a href="Unsafe-Coerce.html#v:unsafeCoerce" title="Unsafe.Coerce">unsafeCoerce</a></code>:</p><ol><li value="1">To coerce a lifted type such as <code>Int</code> to <code>Any</code>, put it in a list of <code>Any</code>,
      and then later coerce it back to <code>Int</code> before using it.</li><li value="2">To produce e.g. <code>(a+b) :~: (b+a)</code> from <code>unsafeCoerce Refl</code>.
      Here the two sides really are the same type -- so nothing unsafe is happening
      -- but GHC is not clever enough to see it.</li><li value="3">In <code>Data.Typeable</code> we have</li></ol><pre>       eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2).
                    TypeRep a -&gt; TypeRep b -&gt; Maybe (a :~~: b)
       eqTypeRep a b
         | sameTypeRep a b = Just (unsafeCoerce HRefl)
         | otherwise       = Nothing
     </pre><p>Here again, the <code>unsafeCoerce HRefl</code> is safe, because the two types really
      are the same  -- but the proof of that relies on the complex, trusted
      implementation of <code>Typeable</code>.</p><ol><li value="4">(superseded) The &quot;reflection trick&quot;, which takes advantage of the fact that in
      <code>class C a where { op :: ty }</code>, we can safely coerce between <code>C a</code> and <code>ty</code>
      (which have different kinds!) because it's really just a newtype.
      Note: there is <em>no guarantee, at all</em> that this behavior will be supported
      into perpetuity.
      It is now preferred to use <code><a href="GHC-Exts.html#v:withDict" title="GHC.Exts">withDict</a></code> in <code>GHC.Magic.Dict</code>, which
      is type-safe. See Note [withDict] in GHC.Tc.Instance.Class for details.</li><li value="5">(superseded) Casting between two types which have exactly the same structure:
      between a newtype of T and T, or between types which differ only
      in &quot;phantom&quot; type parameters.
      It is now preferred to use <code><a href="Data-Coerce.html#v:coerce" title="Data.Coerce">coerce</a></code> from <code>Data.Coerce</code>, which
      is type-safe.</li></ol><p>Other uses of <code><a href="Unsafe-Coerce.html#v:unsafeCoerce" title="Unsafe.Coerce">unsafeCoerce</a></code> are undefined.  In particular, you should not use
  <code><a href="Unsafe-Coerce.html#v:unsafeCoerce" title="Unsafe.Coerce">unsafeCoerce</a></code> to cast a T to an algebraic data type D, unless T is also
  an algebraic data type.  For example, do not cast <code><code><a href="Data-Int.html#t:Int" title="Data.Int">Int</a></code>-&gt;<code><a href="Data-Int.html#t:Int" title="Data.Int">Int</a></code></code> to <code><a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>, even if
  you later cast that <code><a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code> back to <code><code><a href="Data-Int.html#t:Int" title="Data.Int">Int</a></code>-&gt;<code><a href="Data-Int.html#t:Int" title="Data.Int">Int</a></code></code> before applying it.  The reasons
  have to do with GHC's internal representation details (for the cognoscenti, data values
  can be entered but function closures cannot).  If you want a safe type to cast things
  to, use <code><a href="GHC-Exts.html#t:Any" title="GHC.Exts">Any</a></code>, which is not an algebraic data type.</p></div></div><div class="top"><p class="src"><a id="v:unsafeCoerceUnlifted" class="def">unsafeCoerceUnlifted</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Exts.html#t:UnliftedType" title="GHC.Exts">UnliftedType</a>) (b :: <a href="GHC-Exts.html#t:UnliftedType" title="GHC.Exts">UnliftedType</a>). a -&gt; b <a href="src/Unsafe.Coerce.html#unsafeCoerceUnlifted" class="link">Source</a> <a href="#v:unsafeCoerceUnlifted" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:unsafeCoerceAddr" class="def">unsafeCoerceAddr</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> '<a href="GHC-Exts.html#v:AddrRep" title="GHC.Exts">AddrRep</a>) (b :: <a href="GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> '<a href="GHC-Exts.html#v:AddrRep" title="GHC.Exts">AddrRep</a>). a -&gt; b <a href="src/Unsafe.Coerce.html#unsafeCoerceAddr" class="link">Source</a> <a href="#v:unsafeCoerceAddr" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:unsafeEqualityProof" class="def">unsafeEqualityProof</a> :: <span class="keyword">forall</span> {k} (a :: k) (b :: k). <a href="Unsafe-Coerce.html#t:UnsafeEquality" title="Unsafe.Coerce">UnsafeEquality</a> a b <a href="src/Unsafe.Coerce.html#unsafeEqualityProof" class="link">Source</a> <a href="#v:unsafeEqualityProof" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:UnsafeEquality" class="def">UnsafeEquality</a> (a :: k) (b :: k) <span class="keyword">where</span> <a href="src/Unsafe.Coerce.html#UnsafeEquality" class="link">Source</a> <a href="#t:UnsafeEquality" class="selflink">#</a></p><div class="doc"><p>This type is treated magically within GHC. Any pattern match of the
 form <code>case unsafeEqualityProof of UnsafeRefl -&gt; body</code> gets transformed just into <code>body</code>.
 This is ill-typed, but the transformation takes place after type-checking is
 complete. It is used to implement <code><a href="Unsafe-Coerce.html#v:unsafeCoerce" title="Unsafe.Coerce">unsafeCoerce</a></code>. You probably don't want to
 use <code><a href="Unsafe-Coerce.html#v:UnsafeRefl" title="Unsafe.Coerce">UnsafeRefl</a></code> in an expression, but you might conceivably want to pattern-match
 on it. Use <code><a href="Unsafe-Coerce.html#v:unsafeEqualityProof" title="Unsafe.Coerce">unsafeEqualityProof</a></code> to create one of these.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:UnsafeRefl" class="def">UnsafeRefl</a> :: <span class="keyword">forall</span> {k} (a :: k). <a href="Unsafe-Coerce.html#t:UnsafeEquality" title="Unsafe.Coerce">UnsafeEquality</a> a a</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a id="v:unsafeCoerce-35-" class="def">unsafeCoerce#</a> :: a -&gt; b <a href="src/Unsafe.Coerce.html#unsafeCoerce%23" class="link">Source</a> <a href="#v:unsafeCoerce-35-" class="selflink">#</a></p><div class="doc"><p>Highly, terribly dangerous coercion from one representation type
 to another. Misuse of this function can invite the garbage collector
 to trounce upon your data and then laugh in your face. You don't want
 this function. Really.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>